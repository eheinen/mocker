package internal

import (
	"bufio"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

const (
	interfaceNamePattern          = "type (.+) interface"
	functionNamePattern           = "([\\w]+)\\("
	functionArgumentsPattern      = "\\((.+)\\) "
	functionCompoundReturnPattern = "\\) \\((.+)\\)"
	functionSingleReturnPattern   = "\\) (.+)"

	mocksDirectoryName = "/mocks"
	mockerPathName     = "%s/%s_mocker.go"

	mockAnything = "mock.Anything"
)

var skipFilesInDir = []string{
	"/mocks/.+\\.go",
}

var skipFilesWithName = []string{
	"main.go",
	".+test.go",
	"mocker.go",
}

var userAnythingForTypes = []string{
	"context.Context",
}

type file struct {
	path string
	info os.FileInfo
}

type interfaceDetail struct {
	name      string
	functions []string
}

type functionArgument struct {
	text    string
	details []argumentDetails
}

type argumentDetails struct {
	varName string
	varType string
}

func GenerateMockers() {
	files := walkThroughFiles()
	generateMockers(files)
}

func walkThroughFiles() []file {
	var files []file

	if err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println(err)
			return err
		}

		file := file{path, info}
		if !shouldSkipFile(file) {
			files = append(files, file)
		}

		return nil
	}); err != nil {
		fmt.Println(err)
	}

	return files
}

func generateMockers(files []file) {
	for _, file := range files {
		openedFile := readFile(file.path)

		var details []interfaceDetail

		for openedFile.Scan() {
			var detail interfaceDetail
			detail.name = getStringGroupFromRegex(interfaceNamePattern, openedFile.Text(), 1)
			if len(detail.name) == 0 {
				continue
			}

			var functions []string

			for openedFile.Scan() {
				textLine := openedFile.Text()
				if len(strings.TrimSpace(textLine)) == 0 || strings.Contains("}", textLine) {
					break
				}

				functions = append(functions, cleanText(textLine))
			}

			detail.functions = functions
			details = append(details, detail)
		}

		if len(details) > 0 {
			currentDirectory := path.Dir(file.path)

			currentMockDirectory := currentDirectory + mocksDirectoryName
			if _, err := os.Stat(currentMockDirectory); os.IsNotExist(err) {
				fmt.Println("Creating directory 'mocks'")
				err := os.Mkdir(currentMockDirectory, os.ModePerm)
				if err != nil {
					fmt.Println(err)
				}
			}

			for _, detail := range details {
				var mockerFileBuilder strings.Builder

				buildFileHeader(&mockerFileBuilder)

				for _, function := range detail.functions {
					buildMockFunction(&mockerFileBuilder, function)
					buildAssertMockFunction(&mockerFileBuilder, function)
				}

				mockerFileName := fmt.Sprintf(mockerPathName, currentMockDirectory, strings.TrimRight(file.info.Name(), ".go"))
				writeMockerFile(mockerFileName, &mockerFileBuilder)
			}
		}
	}
}

func buildFileHeader(fileBuilder *strings.Builder) {
	fileBuilder.WriteString("// ------------------MOCKER--------------------\n")
	fileBuilder.WriteString("// DO NOT EDIT THIS FILE, CODE AUTO-GENERATED\n")
	fileBuilder.WriteString("// ------------------MOCKER--------------------\n\n")
	fileBuilder.WriteString("package mocks\n\n")
	fileBuilder.WriteString("import (\n")
	fileBuilder.WriteString("\t\"testing\"\n\n")
	fileBuilder.WriteString("\t\"github.com/stretchr/testify/mock\"\n")
	fileBuilder.WriteString(")\n")
}

func buildMockFunction(fileBuilder *strings.Builder, functionText string) {
	functionName := extractFunctionName(functionText)
	functionArguments := extractFunctionArguments(functionText)
	functionReturns := extractFunctionReturns(functionText)

	buildFunctionComment(fileBuilder, "Mock", functionName, functionArguments, functionReturns)

	if len(functionReturns) > 0 {
		fileBuilder.WriteString(fmt.Sprintf("\nfunc Mock%s(mocking *mock.Mock, expectedReturns ...interface{}) *mock.Call {\n", functionName))
	} else {
		fileBuilder.WriteString(fmt.Sprintf("\nfunc Mock%s(mocking *mock.Mock) *mock.Call {\n", functionName))
	}

	if len(functionArguments.text) > 0 {
		fileBuilder.WriteString(fmt.Sprintf("\treturn mocking.On(\"%s\",\n", functionName))
		for _, argument := range functionArguments.details {
			var useType = fmt.Sprintf("\t\tmock.AnythingOfType(\"%s\"),\n", argument.varType)
			for _, anythingType := range userAnythingForTypes {
				if anythingType == argument.varType {
					useType = fmt.Sprintf("\t\t%s,\n", mockAnything)
				}
			}

			fileBuilder.WriteString(useType)
		}
	} else {
		fileBuilder.WriteString(fmt.Sprintf("\treturn mocking.On(\"%s\"", functionName))
	}

	if len(functionReturns) > 0 {
		if len(functionArguments.text) > 0 {
			fileBuilder.WriteString("\t")
		}

		fileBuilder.WriteString(").Return(expectedReturns...)")
	} else {
		fileBuilder.WriteString(")")
	}

	fileBuilder.WriteString("\n}\n")
}

func buildAssertMockFunction(fileBuilder *strings.Builder, functionText string) {
	functionName := extractFunctionName(functionText)
	functionArguments := extractFunctionArguments(functionText)
	functionReturns := extractFunctionReturns(functionText)

	buildFunctionComment(fileBuilder, "Assert", functionName, functionArguments, []string{})

	if len(functionReturns) > 0 {
		fileBuilder.WriteString(fmt.Sprintf("\nfunc Assert%s(t *testing.T, mocking *mock.Mock, times int, expectedReturns ...interface{}) {", functionName))
		fileBuilder.WriteString("\n\tif times != 0 {\n")
		fileBuilder.WriteString(fmt.Sprintf("\t\tmocking.AssertCalled(t, \"%s\", expectedReturns...)\n", functionName))
		fileBuilder.WriteString("\t}\n")
	} else {
		fileBuilder.WriteString(fmt.Sprintf("\nfunc Assert%s(t *testing.T, mocking *mock.Mock, times int) {", functionName))
	}

	fileBuilder.WriteString(fmt.Sprintf("\n\tmocking.AssertNumberOfCalls(t, \"%s\", times)\n", functionName))
	fileBuilder.WriteString("}\n")
}

func buildFunctionComment(fileBuilder *strings.Builder, namePrefix string, functionName string, functionArguments functionArgument, functionReturns []string) {
	fileBuilder.WriteString(fmt.Sprintf("\n// %s%s", namePrefix, functionName))

	if len(strings.TrimSpace(functionArguments.text)) != 0 {
		fileBuilder.WriteString(fmt.Sprintf("\n// (%s)", functionArguments.text))
	}

	returns := strings.Join(functionReturns, ", ")
	if len(strings.TrimSpace(returns)) != 0 {
		fileBuilder.WriteString(fmt.Sprintf("\n// %s", returns))
	}

	if len(strings.TrimSpace(functionArguments.text)) == 0 && len(strings.TrimSpace(returns)) == 0 {
		fileBuilder.WriteString("\n// No argument and return expected")
	}
}

func extractFunctionName(functionText string) string {
	return getStringGroupFromRegex(functionNamePattern, functionText, 1)
}

func extractFunctionReturns(functionText string) []string {
	functionReturnsString := getStringGroupFromRegex(functionCompoundReturnPattern, functionText, 1)
	if len(strings.TrimSpace(functionReturnsString)) == 0 {
		functionReturnsString = getStringGroupFromRegex(functionSingleReturnPattern, functionText, 1)
	}
	var functionReturns []string
	if len(cleanText(functionReturnsString)) > 0 {
		functionReturns = strings.Split(cleanText(functionReturnsString), ",")
	}

	return functionReturns
}

func extractFunctionArguments(functionText string) functionArgument {
	functionArgumentString := getStringGroupFromRegex(functionArgumentsPattern, functionText, 1)
	var functionArguments []string
	if len(cleanText(functionArgumentString)) > 0 {
		functionArguments = strings.Split(cleanText(functionArgumentString), ",")
	}

	var argDetails []argumentDetails
	for _, argumentReturn := range functionArguments {
		argumentsSplit := strings.Split(cleanText(argumentReturn), " ")

		detail := argumentDetails{
			varName: argumentsSplit[0],
			varType: argumentsSplit[1],
		}

		argDetails = append(argDetails, detail)
	}

	return functionArgument{
		text:    functionArgumentString,
		details: argDetails,
	}
}

func getStringGroupFromRegex(pattern string, text string, groupIndex int) string {
	regex := regexp.MustCompile(pattern)
	regexMatch := regex.FindStringSubmatch(text)
	if len(regexMatch) > 0 {
		return regexMatch[groupIndex]
	}

	return ""
}

func cleanText(text string) string {
	text = strings.ReplaceAll(text, "\t", "")
	text = strings.ReplaceAll(text, "\r", "")
	return strings.TrimSpace(text)
}

func writeMockerFile(mockerFilePath string, fileBuilder *strings.Builder) {
	if len(fileBuilder.String()) > 0 {
		err := os.WriteFile(mockerFilePath, []byte(fileBuilder.String()), 0755)
		if err != nil {
			fmt.Println(err)
		}
	}
}

func shouldSkipFile(file file) bool {
	if !strings.HasSuffix(file.path, ".go") {
		return true
	}

	for _, dir := range skipFilesInDir {
		if len(getStringGroupFromRegex(dir, file.path, 0)) > 0 {
			return true
		}
	}

	for _, fileName := range skipFilesWithName {
		if len(getStringGroupFromRegex(fileName, file.path, 0)) > 0 {
			return true
		}
	}

	return false
}

func readFile(filePath string) *bufio.Scanner {
	readFile, err := os.Open(filePath)
	if err != nil {
		fmt.Println(err)
	}

	fileScanner := bufio.NewScanner(readFile)
	fileScanner.Split(bufio.ScanLines)

	return fileScanner
}
